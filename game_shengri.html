<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸€å¹´çº§è¯†å­—å¤§é—¯å…³ - 100å­—åŠ å¼ºç‰ˆ</title>
    <style>
        /* ==================== 1. å…¨å±€æ ·å¼ä¸é‡ç½® ==================== */
        :root {
            --bg-color: #fdfbf2;
            --primary-color: #ff9800;
            --accent-green: #8bc34a;
            --accent-blue: #4fc3f7;
            --text-color: #5d4037;
            --paper-line: rgba(0, 0, 0, 0.05);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: "KaiTi", "STKaiti", "æ¥·ä½“", serif;
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(var(--paper-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--paper-line) 1px, transparent 1px);
            background-size: 40px 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
            overscroll-behavior: none; /* é˜²æ­¢iOSæ©¡çš®ç­‹æ•ˆæœ */
        }

        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 960px;
            max-height: 540px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        @media (orientation: portrait) {
            #app-container {
                max-width: 100%;
                max-height: 100%;
                border-radius: 0;
            }
        }

        /* ==================== 2. é€šç”¨ UI ç»„ä»¶ ==================== */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .screen.active {
            display: flex;
        }

        /* é¡¶éƒ¨ HUD */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            pointer-events: none;
            background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0));
        }

        .hud-btn {
            pointer-events: auto;
            background: #ffccbc;
            border: 2px solid #ff5722;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: #d84315;
            cursor: pointer;
            font-family: inherit;
            font-size: 1.1rem;
        }

        .hud-score {
            font-size: 1.8rem;
            color: #ff9800;
            text-shadow: 1px 1px 0 #fff;
            font-weight: bold;
            background: rgba(255,255,255,0.9);
            padding: 5px 20px;
            border-radius: 20px;
            border: 2px solid #ffe0b2;
        }

        /* ==================== 3. é¦–é¡µæ ·å¼ ==================== */
        .menu-title {
            font-size: 3.5rem;
            color: #d84315;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 #fff;
            text-align: center;
        }

        .mode-select {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 20px;
        }

        .mode-card {
            width: 200px;
            height: 240px;
            background: #fff;
            border-radius: 20px;
            border: 5px solid #ddd;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 8px 0 rgba(0,0,0,0.1);
        }

        .mode-card:hover { transform: translateY(-5px); }
        .mode-card:active { transform: translateY(5px); box-shadow: none; }

        .mode-card.trace { border-color: var(--primary-color); }
        .mode-card.shoot { border-color: var(--accent-blue); }
        .mode-card.puzzle { border-color: var(--accent-green); }

        .mode-icon { font-size: 4.5rem; margin-bottom: 15px; }
        .mode-name { font-size: 1.6rem; font-weight: bold; }

        /* ==================== 4. æ¸¸æˆåŒºåŸŸæ ·å¼ ==================== */
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
        }

        /* ç”°å­—æ ¼å®¹å™¨ */
        .tian-grid {
            width: 320px;
            height: 320px;
            border: 4px solid #d84315;
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: 
                linear-gradient(#d84315 1px, transparent 1px) center/100% 1px no-repeat,
                linear-gradient(90deg, #d84315 1px, transparent 1px) center/1px 100% no-repeat,
                linear-gradient(45deg, transparent 49.5%, #ffccbc 50%, transparent 50.5%),
                linear-gradient(-45deg, transparent 49.5%, #ffccbc 50%, transparent 50.5%);
            background-size: 100% 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        /* æ‹¼å›¾éƒ¨ä»¶ */
        .puzzle-piece {
            width: 100px;
            height: 100px;
            background: #fff;
            border: 3px solid #5d4037;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            position: absolute;
            cursor: grab;
            box-shadow: 4px 4px 10px rgba(0,0,0,0.2);
            touch-action: none;
            z-index: 10;
        }
        .puzzle-piece.locked {
            border-color: #8bc34a;
            background-color: #f1f8e9;
            box-shadow: none;
            z-index: 1;
            cursor: default;
        }
        .puzzle-target-zone {
            position: absolute;
            border: 3px dashed #999;
            background: rgba(255,255,255,0.4);
            border-radius: 12px;
        }
    </style>
</head>
<body>

<div id="app-container">
    
    <!-- 1. é¦–é¡µèœå• -->
    <div id="screen-menu" class="screen active">
        <div class="menu-title">ğŸ¯ è¯†å­—å¤§é—¯å…³</div>
        <div class="mode-select">
            <div class="mode-card trace" onclick="GameManager.startMode('trace')">
                <div class="mode-icon">âœï¸</div>
                <div class="mode-name">è¶£å‘³æçº¢</div>
                <div style="font-size:0.9rem; color:#666; margin-top:5px;">è‡ªç„¶ç¬”è§¦ ç»ƒå¥½å­—</div>
            </div>
            <div class="mode-card shoot" onclick="GameManager.startMode('shoot')">
                <div class="mode-icon">ğŸˆ</div>
                <div class="mode-name">è¾¨å­—å°„å‡»</div>
                <div style="font-size:0.9rem; color:#666; margin-top:5px;">çœ¼ç–¾æ‰‹å¿« æ‰¾æ±‰å­—</div>
            </div>
            <div class="mode-card puzzle" onclick="GameManager.startMode('puzzle')">
                <div class="mode-icon">ğŸ§©</div>
                <div class="mode-name">æ‹¼å­—ç§¯æœ¨</div>
                <div style="font-size:0.9rem; color:#666; margin-top:5px;">æ‹†è§£ç»“æ„ æ‹¼ç”Ÿå­—</div>
            </div>
        </div>
    </div>

    <!-- 2. æ¸¸æˆå®¹å™¨ -->
    <div id="screen-game" class="screen">
        <div class="hud">
            <div class="hud-btn" onclick="GameManager.backToMenu()">â¬… é€€å‡º</div>
            <div class="hud-score" id="score-display">â­ 0</div>
        </div>
        <div id="game-area"></div>
    </div>

</div>

<script>
/**
 * ==========================================
 * 1. æ ¸å¿ƒæ•°æ®ä¸­å¿ƒ (100å­—åŠ å¼ºç‰ˆ)
 * ==========================================
 * ç¬”ç”»æ•°æ®æ ¼å¼å‡çº§ï¼š
 * æ”¯æŒè´å¡å°”æ›²çº¿ï¼Œæ ¼å¼ï¼š[{x,y}, {type:'Q', cx, cy, x, y}] 
 * Q ä»£è¡¨äºŒæ¬¡è´å¡å°”æ›²çº¿ï¼Œcx,cyä¸ºæ§åˆ¶ç‚¹
 */
const WORD_DB = [
    // --- ç¬”ç”»ç²¾ä¿®ç¤ºèŒƒå­— (è´å¡å°”æ›²çº¿ä¼˜åŒ–) ---
    { 
        char: "ä¸€", pinyin: "yÄ«", trace: true, 
        strokes: [[{x:15,y:50},{x:85,y:50}]] 
    },
    { 
        char: "äºŒ", pinyin: "Ã¨r", trace: true, 
        strokes: [
            [{x:25,y:30},{x:75,y:30}], 
            [{x:15,y:75},{x:85,y:75}]
        ] 
    },
    { 
        char: "ä¸‰", pinyin: "sÄn", trace: true, 
        strokes: [
            [{x:25,y:25},{x:75,y:25}], 
            [{x:30,y:50},{x:70,y:50}], 
            [{x:15,y:80},{x:85,y:80}]
        ] 
    },
    { 
        char: "äºº", pinyin: "rÃ©n", trace: true, 
        strokes: [
            [{x:50,y:10}, {type:'Q', cx:40, cy:40, x:10, y:80}], // æ’‡ (è‡ªç„¶å¼¯æ›²)
            [{x:50,y:35}, {type:'Q', cx:60, cy:55, x:90, y:80}]  // æº (è‡ªç„¶å¼¯æ›²)
        ] 
    },
    { 
        char: "å¤§", pinyin: "dÃ ", trace: true, 
        strokes: [
            [{x:15,y:40},{x:85,y:40}], // æ¨ª
            [{x:50,y:10}, {type:'Q', cx:40, cy:50, x:10, y:85}], // æ’‡
            [{x:50,y:40}, {type:'Q', cx:65, cy:60, x:90, y:85}]  // æº
        ] 
    },
    { 
        char: "å¤©", pinyin: "tiÄn", trace: true, 
        strokes: [
            [{x:25,y:30},{x:75,y:30}], 
            [{x:10,y:55},{x:90,y:55}],
            [{x:50,y:30}, {type:'Q', cx:35, cy:60, x:10, y:85}], 
            [{x:50,y:55}, {type:'Q', cx:65, cy:70, x:90, y:85}]
        ] 
    },
    { 
        char: "ç«", pinyin: "huÇ’", trace: true,
        strokes: [
            [{x:15,y:50}, {type:'Q', cx:20, cy:60, x:25, y:70}], // ç‚¹
            [{x:85,y:50}, {type:'Q', cx:80, cy:60, x:75, y:70}], // çŸ­æ’‡
            [{x:50,y:20}, {type:'Q', cx:40, cy:50, x:10, y:85}], // ç«–æ’‡
            [{x:50,y:40}, {type:'Q', cx:65, cy:60, x:90, y:85}]  // æº
        ]
    },
    { 
        char: "æœ¨", pinyin: "mÃ¹", trace: true,
        strokes: [
            [{x:15,y:40}, {x:85,y:40}], // æ¨ª
            [{x:50,y:15}, {x:50,y:85}], // ç«–
            [{x:50,y:40}, {type:'Q', cx:35, cy:60, x:15, y:85}], // æ’‡
            [{x:50,y:40}, {type:'Q', cx:65, cy:60, x:85, y:85}]  // æº
        ]
    },
    { 
        char: "å£", pinyin: "kÇ’u", trace: true,
        strokes: [
            [{x:25,y:25}, {x:25,y:75}], // ç«–
            [{x:25,y:25}, {x:75,y:25}, {x:75,y:75}], // æ¨ªæŠ˜
            [{x:25,y:75}, {x:75,y:75}] // æ¨ª
        ]
    },
    { 
        char: "æ—¥", pinyin: "rÃ¬", trace: true,
        strokes: [
            [{x:25,y:15}, {x:25,y:85}], 
            [{x:25,y:15}, {x:75,y:15}, {x:75,y:85}], 
            [{x:25,y:50}, {x:75,y:50}], 
            [{x:25,y:85}, {x:75,y:85}]
        ]
    },
    
    // --- æ‹¼å›¾/åˆä½“å­—ç»“æ„é…ç½® ---
    { char: "æ˜", pinyin: "mÃ­ng", puzzle: true, type: "lr", parts: [{text:"æ—¥", x:-1}, {text:"æœˆ", x:1}] },
    { char: "å¦ˆ", pinyin: "mÄ", puzzle: true, type: "lr", parts: [{text:"å¥³", x:-1}, {text:"é©¬", x:1}] },
    { char: "çˆ¸", pinyin: "bÃ ", puzzle: true, type: "tb", parts: [{text:"çˆ¶", y:-1}, {text:"å·´", y:1}] },
    { char: "ç”·", pinyin: "nÃ¡n", puzzle: true, type: "tb", parts: [{text:"ç”°", y:-1}, {text:"åŠ›", y:1}] },
    { char: "æ—", pinyin: "lÃ­n", puzzle: true, type: "lr", parts: [{text:"æœ¨", x:-1}, {text:"æœ¨", x:1}] },
    { char: "ä»", pinyin: "cÃ³ng", puzzle: true, type: "lr", parts: [{text:"äºº", x:-1}, {text:"äºº", x:1}] },
    { char: "å’Œ", pinyin: "hÃ©", puzzle: true, type: "lr", parts: [{text:"ç¦¾", x:-1}, {text:"å£", x:1}] },
    
    // --- 100ç”Ÿå­—å¿«é€Ÿæ‰©å…… (é€šç”¨é…ç½®ï¼Œç”¨äºå°„å‡»/è®¤è¯») ---
    // ä¸ºäº†ä»£ç ç®€æ´ï¼Œè¿™é‡Œåˆ—å‡ºå¸¸è§å­—ï¼Œå®é™…è¿è¡Œæ—¶ä¼šéšæœºæŠ½å–
    { char: "å±±", pinyin: "shÄn" }, { char: "çŸ³", pinyin: "shÃ­" }, { char: "ç”°", pinyin: "tiÃ¡n" },
    { char: "åœŸ", pinyin: "tÇ”" }, { char: "æ°´", pinyin: "shuÇ" }, { char: "äº‘", pinyin: "yÃºn" },
    { char: "é›¨", pinyin: "yÇ”" }, { char: "é£", pinyin: "fÄ“ng" }, { char: "èŠ±", pinyin: "huÄ" },
    { char: "é¸Ÿ", pinyin: "niÇo" }, { char: "è™«", pinyin: "chÃ³ng" }, { char: "å…­", pinyin: "liÃ¹" },
    { char: "ä¸ƒ", pinyin: "qÄ«" }, { char: "å…«", pinyin: "bÄ" }, { char: "ä¹", pinyin: "jiÇ”" },
    { char: "å", pinyin: "shÃ­" }, { char: "ä¸Š", pinyin: "shÃ ng" }, { char: "ä¸‹", pinyin: "xiÃ " },
    { char: "å·¦", pinyin: "zuÇ’" }, { char: "å³", pinyin: "yÃ²u" }, { char: "ä¸­", pinyin: "zhÅng" },
    { char: "è€³", pinyin: "Ä›r" }, { char: "ç›®", pinyin: "mÃ¹" }, { char: "æ‰‹", pinyin: "shÇ’u" },
    { char: "è¶³", pinyin: "zÃº" }, { char: "ç«™", pinyin: "zhÃ n" }, { char: "å", pinyin: "zuÃ²" },
    { char: "æœˆ", pinyin: "yuÃ¨" }, { char: "å„¿", pinyin: "Ã©r" }, { char: "å¤´", pinyin: "tÃ³u" },
    { char: "é‡Œ", pinyin: "lÇ" }, { char: "å¯", pinyin: "kÄ›" }, { char: "ä¸œ", pinyin: "dÅng" },
    { char: "è¥¿", pinyin: "xÄ«" }, { char: "åŒ—", pinyin: "bÄ›i" }, { char: "å—", pinyin: "nÃ¡n" },
    { char: "æ˜¯", pinyin: "shÃ¬" }, { char: "å¥³", pinyin: "nÇš" }, { char: "å¼€", pinyin: "kÄi" },
    { char: "å…³", pinyin: "guÄn" }, { char: "æ­£", pinyin: "zhÃ¨ng" }, { char: "å", pinyin: "fÇn" },
    { char: "å¤š", pinyin: "duÅ" }, { char: "å°‘", pinyin: "shÇo" }, { char: "å°", pinyin: "xiÇo" },
    { char: "ç‰›", pinyin: "niÃº" }, { char: "ç¾Š", pinyin: "yÃ¡ng" }, { char: "æœ", pinyin: "guÇ’" },
    { char: "å¿ƒ", pinyin: "xÄ«n" }, { char: "ç«‹", pinyin: "lÃ¬" }, { char: "åˆ€", pinyin: "dÄo" },
    { char: "åŠ›", pinyin: "lÃ¬" }, { char: "é—¨", pinyin: "mÃ©n" }, { char: "ç™½", pinyin: "bÃ¡i" },
    { char: "å°º", pinyin: "chÇ" }, { char: "æœ¬", pinyin: "bÄ›n" }, { char: "æ—©", pinyin: "zÇo" },
    { char: "ä¹¦", pinyin: "shÅ«" }, { char: "ç‰™", pinyin: "yÃ¡" }, { char: "å»", pinyin: "qÃ¹" },
    { char: "æ¥", pinyin: "lÃ¡i" }, { char: "å·¥", pinyin: "gÅng" }, { char: "å‚", pinyin: "chÇng" }
];

// è¾…åŠ©ï¼šè·å–ç¬¦åˆæ¨¡å¼çš„å­—åº“
function getWordsForMode(mode) {
    if (mode === 'trace') return WORD_DB.filter(w => w.trace);
    if (mode === 'puzzle') return WORD_DB.filter(w => w.puzzle);
    return WORD_DB; // shoot æ¨¡å¼æ‰€æœ‰å­—éƒ½è¡Œ
}

// è¾…åŠ©ï¼šè·å–å¹²æ‰°é¡¹
function getDistractors(targetChar, count) {
    const allChars = WORD_DB.map(w => w.char).filter(c => c !== targetChar);
    // éšæœºæ‰“ä¹±å–å‰ count ä¸ª
    return allChars.sort(() => 0.5 - Math.random()).slice(0, count);
}

/**
 * ==========================================
 * 2. éŸ³é¢‘ç®¡ç†å™¨
 * ==========================================
 */
const AudioManager = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        const now = this.ctx.currentTime;
        if (type === 'correct') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'wrong') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(100, now + 0.2);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }
    },
    speak: function(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'zh-CN';
            u.rate = 1;
            window.speechSynthesis.speak(u);
        }
    }
};

/**
 * ==========================================
 * 3. æ¸¸æˆç®¡ç†å™¨
 * ==========================================
 */
const GameManager = {
    currentMode: null,
    currentInstance: null,
    score: 0,
    container: document.getElementById('game-area'),

    startMode: function(mode) {
        AudioManager.init();
        document.getElementById('screen-menu').classList.remove('active');
        document.getElementById('screen-game').classList.add('active');
        this.currentMode = mode;
        this.score = 0;
        this.updateScore();
        setTimeout(() => this.nextRound(), 100);
    },

    backToMenu: function() {
        if (this.currentInstance && this.currentInstance.destroy) this.currentInstance.destroy();
        document.getElementById('screen-game').classList.remove('active');
        document.getElementById('screen-menu').classList.add('active');
        AudioManager.speak("ä¼‘æ¯ä¸€ä¸‹");
    },

    updateScore: function(add = 0) {
        this.score += add;
        document.getElementById('score-display').innerText = `â­ ${this.score}`;
    },

    nextRound: function() {
        const candidates = getWordsForMode(this.currentMode);
        if (candidates.length === 0) {
            alert("è¯¥æ¨¡å¼æš‚æ— é¢˜ç›®");
            this.backToMenu();
            return;
        }
        const word = candidates[Math.floor(Math.random() * candidates.length)];
        
        if (this.currentInstance && this.currentInstance.destroy) this.currentInstance.destroy();
        this.container.innerHTML = '';

        if (this.currentMode === 'trace') {
            this.currentInstance = new TracingMode(this.container, word, () => this.roundComplete());
        } else if (this.currentMode === 'shoot') {
            this.currentInstance = new ShootingMode(this.container, word, () => this.roundComplete());
        } else if (this.currentMode === 'puzzle') {
            this.currentInstance = new PuzzleMode(this.container, word, () => this.roundComplete());
        }
    },

    roundComplete: function() {
        this.updateScore(1);
        AudioManager.playTone('correct');
        AudioManager.speak("å¤ªæ£’äº†ï¼");
        setTimeout(() => this.nextRound(), 1500);
    }
};

/**
 * ==========================================
 * 4. æ¨¡å¼ä¸€ï¼šè¶£å‘³æçº¢ (è´å¡å°”æ›²çº¿å‡çº§ç‰ˆ)
 * ==========================================
 */
class TracingMode {
    constructor(container, data, onWin) {
        this.container = container;
        this.data = data;
        this.onWin = onWin;
        this.currentStroke = 0;
        this.strokePoints = [];
        this.isDrawing = false;
        this.frameId = null;
        this.init();
    }

    init() {
        AudioManager.speak(`è¯·å†™ï¼Œ${this.data.char}`);
        
        const grid = document.createElement('div');
        grid.className = 'tian-grid';
        this.container.appendChild(grid);

        this.canvas = document.createElement('canvas');
        this.canvas.width = 320;
        this.canvas.height = 320;
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        grid.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');

        this.bindEvents();
        this.draw();
    }

    // æ ¸å¿ƒæ¸²æŸ“æ–¹æ³•
    draw() {
        if (!this.ctx) return;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. ç»˜åˆ¶åº•å±‚çš„æ¥·ä½“å­—ä½œä¸ºæœ€ç»ˆå‚è€ƒ
        this.ctx.font = "260px KaiTi";
        this.ctx.fillStyle = "#eee";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(this.data.char, 160, 160);

        // 2. ç»˜åˆ¶å·²å®Œæˆçš„ç¬”ç”» (æ·±è‰²å¢¨è¿¹)
        this.ctx.lineWidth = 25;
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";
        this.ctx.strokeStyle = "#3e2723";
        
        for (let i = 0; i < this.currentStroke; i++) {
            this.drawStrokePath(this.data.strokes[i]);
        }

        // 3. ç»˜åˆ¶ç”¨æˆ·å½“å‰çš„ç¬”è¿¹
        if (this.strokePoints.length > 0) {
            this.ctx.strokeStyle = "#d84315"; // æ©™çº¢è‰²
            this.ctx.beginPath();
            this.ctx.moveTo(this.strokePoints[0].x, this.strokePoints[0].y);
            for(let p of this.strokePoints) {
                this.ctx.lineTo(p.x, p.y);
            }
            this.ctx.stroke();
        }

        this.frameId = requestAnimationFrame(() => this.draw());
    }

    // æ”¯æŒè´å¡å°”æ›²çº¿çš„è·¯å¾„ç»˜åˆ¶
    drawStrokePath(points) {
        if (!points || points.length === 0) return;
        this.ctx.beginPath();
        const start = this.scalePoint(points[0]);
        this.ctx.moveTo(start.x, start.y);
        
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            const target = this.scalePoint(p);
            
            if (p.type === 'Q') { // äºŒæ¬¡è´å¡å°”æ›²çº¿
                const control = this.scalePoint({x: p.cx, y: p.cy});
                this.ctx.quadraticCurveTo(control.x, control.y, target.x, target.y);
            } else {
                this.ctx.lineTo(target.x, target.y);
            }
        }
        this.ctx.stroke();
    }

    scalePoint(p) {
        // ç”»å¸ƒ320x320ï¼Œæ•°æ®0-100ï¼Œç¼©æ”¾ç³»æ•°3.2
        return { x: p.x * 3.2, y: p.y * 3.2 };
    }

    bindEvents() {
        const start = (e) => {
            e.preventDefault();
            this.isDrawing = true;
            this.strokePoints = [];
            const pos = this.getPos(e);
            
            // æ£€æŸ¥èµ·ç¬”ä½ç½®
            const targetStroke = this.data.strokes[this.currentStroke];
            if (!targetStroke) return;
            const startP = this.scalePoint(targetStroke[0]);
            
            // å®½æ¾åˆ¤å®šåŠå¾„ 60px
            if (this.dist(pos, startP) < 60) {
                this.strokePoints.push(pos);
            } else {
                this.isDrawing = false; // èµ·ç¬”å¤ªè¿œæ— æ•ˆ
            }
        };

        const move = (e) => {
            if (!this.isDrawing) return;
            e.preventDefault();
            const pos = this.getPos(e);
            this.strokePoints.push(pos);
        };

        const end = (e) => {
            if (!this.isDrawing) return;
            this.isDrawing = false;
            
            // æ£€æŸ¥ç»ˆç¬”ä½ç½®
            const targetStroke = this.data.strokes[this.currentStroke];
            if (!targetStroke) return;
            
            // è·å–ç¬”ç”»æœ€åä¸€ç‚¹
            const lastDataPoint = targetStroke[targetStroke.length - 1];
            const endP = this.scalePoint(lastDataPoint);
            const lastUserP = this.strokePoints[this.strokePoints.length - 1];

            if (lastUserP && this.dist(lastUserP, endP) < 60) {
                this.currentStroke++;
                AudioManager.playTone('correct');
                if (this.currentStroke >= this.data.strokes.length) {
                    this.onWin();
                }
            } else {
                // æ²¡å†™åˆ°ä½ï¼Œç¬”è¿¹è‡ªåŠ¨æ¶ˆå¤±ï¼Œä¸æŠ¥é”™
            }
            this.strokePoints = [];
        };

        this.canvas.addEventListener('mousedown', start);
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('mousemove', move);
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('mouseup', end);
        window.addEventListener('touchend', end, {passive: false});

        this.cleanup = () => {
            window.removeEventListener('mousemove', move);
            window.removeEventListener('touchmove', move);
            window.removeEventListener('mouseup', end);
            window.removeEventListener('touchend', end);
            if (this.frameId) cancelAnimationFrame(this.frameId);
        };
    }

    getPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    dist(p1, p2) {
        return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }
    
    destroy() { if (this.cleanup) this.cleanup(); }
}

/**
 * ==========================================
 * 5. æ¨¡å¼äºŒï¼šè¾¨å­—å°„å‡» (å¤§å­—ä½“ä¿®å¤ç‰ˆ)
 * ==========================================
 */
class ShootingMode {
    constructor(container, data, onWin) {
        this.container = container;
        this.data = data;
        this.onWin = onWin;
        this.balloons = [];
        this.score = 0;
        this.targetScore = 3;
        this.animationFrameId = null;
        this.init();
    }

    init() {
        AudioManager.speak(`è¯·æ‰¾ï¼Œ${this.data.char}`);
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.container.offsetWidth || 800;
        this.canvas.height = this.container.offsetHeight || 450;
        this.container.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        
        this.bindEvents();
        this.running = true;
        this.loop(0);
    }

    spawnBalloon() {
        const isTarget = Math.random() > 0.6;
        const distractors = getDistractors(this.data.char, 8);
        const text = isTarget ? this.data.char : distractors[Math.floor(Math.random() * distractors.length)];
        
        this.balloons.push({
            x: Math.random() * (this.canvas.width - 100) + 50,
            y: this.canvas.height + 60,
            r: 50, // æ°”çƒæ›´å¤§
            text: text,
            speed: 100 + Math.random() * 80,
            color: isTarget ? '#ffecb3' : `hsl(${Math.random()*360}, 85%, 90%)`,
            isTarget: text === this.data.char
        });
    }

    update(dt) {
        this.spawnTimer = (this.spawnTimer || 0) + dt;
        if (this.spawnTimer > 0.8) { 
            this.spawnBalloon();
            this.spawnTimer = 0;
        }
        for (let i = this.balloons.length - 1; i >= 0; i--) {
            let b = this.balloons[i];
            b.y -= b.speed * dt;
            if (b.y < -70) this.balloons.splice(i, 1);
        }
    }

    draw() {
        if (!this.ctx) return;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // ç»˜åˆ¶èƒŒæ™¯å¤§å­—æç¤º
        this.ctx.save();
        this.ctx.font = "bold 250px KaiTi";
        this.ctx.fillStyle = "rgba(0,0,0,0.04)";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(this.data.char, this.canvas.width/2, this.canvas.height/2);
        
        // é¡¶éƒ¨é¢˜ç›®æç¤º
        this.ctx.font = "28px KaiTi";
        this.ctx.fillStyle = "#d84315";
        this.ctx.fillText(`è¯·ç‚¹å‡»ï¼š${this.data.char} ${this.data.pinyin || ''}`, this.canvas.width/2, 80);
        this.ctx.restore();

        // ç»˜åˆ¶æ°”çƒ
        for (let b of this.balloons) {
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            this.ctx.fillStyle = b.color;
            this.ctx.fill();
            this.ctx.lineWidth = 3;
            this.ctx.strokeStyle = "#fff";
            this.ctx.stroke();

            // æ°”çƒæ–‡å­— (åŠ å¤§)
            this.ctx.font = "bold 55px KaiTi";
            this.ctx.fillStyle = "#4e342e";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(b.text, b.x, b.y);
        }
    }

    loop(timestamp) {
        if (!this.running) return;
        const dt = (timestamp - (this.lastTime || timestamp)) / 1000;
        this.lastTime = timestamp;
        if (dt < 0.5) this.update(dt);
        this.draw();
        this.animationFrameId = requestAnimationFrame((t) => this.loop(t));
    }

    bindEvents() {
        this.clickHandler = (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            // ç®€å•çš„åæ ‡æ˜ å°„
            const x = (cx - rect.left) * (this.canvas.width / rect.width);
            const y = (cy - rect.top) * (this.canvas.height / rect.height);

            for (let i = this.balloons.length - 1; i >= 0; i--) {
                let b = this.balloons[i];
                if (Math.sqrt((x-b.x)**2 + (y-b.y)**2) < b.r + 10) {
                    if (b.isTarget) {
                        this.score++;
                        AudioManager.playTone('correct');
                        if (this.score >= this.targetScore) {
                            this.running = false;
                            this.onWin();
                        }
                    } else {
                        AudioManager.playTone('wrong');
                    }
                    this.balloons.splice(i, 1);
                    return;
                }
            }
        };
        this.canvas.addEventListener('mousedown', this.clickHandler);
        this.canvas.addEventListener('touchstart', this.clickHandler, {passive:false});
        
        this.cleanup = () => {
            this.running = false;
            cancelAnimationFrame(this.animationFrameId);
            if(this.canvas) {
                this.canvas.removeEventListener('mousedown', this.clickHandler);
                this.canvas.removeEventListener('touchstart', this.clickHandler);
            }
        };
    }
    destroy() { if (this.cleanup) this.cleanup(); }
}

/**
 * ==========================================
 * 6. æ¨¡å¼ä¸‰ï¼šæ‹¼å­—ç§¯æœ¨
 * ==========================================
 */
class PuzzleMode {
    constructor(container, data, onWin) {
        this.container = container;
        this.data = data;
        this.onWin = onWin;
        this.listeners = [];
        this.init();
    }

    init() {
        AudioManager.speak("è¯·æ‹¼å‡ºï¼Œ" + this.data.char);
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'width:100%;height:100%;position:relative;';
        this.container.appendChild(wrapper);

        const grid = document.createElement('div');
        grid.className = 'tian-grid';
        wrapper.appendChild(grid);
        
        // ç›®æ ‡åŒºåŸŸ
        this.targets = [];
        this.data.parts.forEach((part) => {
            const zone = document.createElement('div');
            zone.className = 'puzzle-target-zone';
            if (this.data.type === 'lr') {
                zone.style.width = '48%'; zone.style.height = '90%';
                zone.style.top = '5%'; zone.style.left = part.x === -1 ? '1%' : '51%';
            } else {
                zone.style.width = '90%'; zone.style.height = '48%';
                zone.style.left = '5%'; zone.style.top = part.y === -1 ? '1%' : '51%';
            }
            grid.appendChild(zone);
            this.targets.push({ el: zone, text: part.text, filled: false });
        });

        // æ•£è½éƒ¨ä»¶
        setTimeout(() => {
            const w = wrapper.offsetWidth, h = wrapper.offsetHeight;
            this.data.parts.forEach((part, i) => {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece';
                piece.innerText = part.text;
                // åˆ†å¸ƒåœ¨å·¦å³ä¸¤ä¾§ç©ºåœ°
                const side = i % 2 === 0 ? 0.15 : 0.85; 
                piece.style.left = (w * side - 50) + 'px';
                piece.style.top = (h/2 - 50 + (Math.random()-0.5)*100) + 'px';
                
                wrapper.appendChild(piece);
                this.makeDraggable(piece, part.text);
            });
        }, 50);
    }

    makeDraggable(el, text) {
        let startX, startY, initL, initT, dragging = false;
        
        const start = (e) => {
            if (el.classList.contains('locked')) return;
            e.preventDefault();
            const p = e.touches ? e.touches[0] : e;
            startX = p.clientX; startY = p.clientY;
            // å¢åŠ å®‰å…¨æ ¡éªŒï¼Œé˜²æ­¢ parseNaN
            initL = parseFloat(el.style.left) || 0; 
            initT = parseFloat(el.style.top) || 0;
            el.style.zIndex = 100; el.style.transition = 'none';
            dragging = true;
        };
        const move = (e) => {
            if (!dragging) return;
            e.preventDefault();
            const p = e.touches ? e.touches[0] : e;
            el.style.left = (initL + p.clientX - startX) + 'px';
            el.style.top = (initT + p.clientY - startY) + 'px';
        };
        const end = () => {
            if (!dragging) return;
            dragging = false; el.style.zIndex = 10;
            
            // ç¢°æ’æ£€æµ‹
            const r = el.getBoundingClientRect();
            const cx = r.left + r.width/2, cy = r.top + r.height/2;
            let matched = false;
            
            for(let t of this.targets) {
                if(t.text === text && !t.filled) {
                    const tr = t.el.getBoundingClientRect();
                    if(cx > tr.left && cx < tr.right && cy > tr.top && cy < tr.bottom) {
                        el.classList.add('locked');
                        const cr = this.container.getBoundingClientRect();
                        el.style.left = (tr.left - cr.left + (tr.width-r.width)/2) + 'px';
                        el.style.top = (tr.top - cr.top + (tr.height-r.height)/2) + 'px';
                        t.filled = true; matched = true;
                        AudioManager.playTone('correct');
                        if(this.targets.every(x=>x.filled)) this.onWin();
                        break;
                    }
                }
            }
            if(!matched) el.style.transition = 'all 0.3s';
        };
        
        el.addEventListener('mousedown', start); el.addEventListener('touchstart', start, {passive:false});
        window.addEventListener('mousemove', move); window.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('mouseup', end); window.addEventListener('touchend', end, {passive:false});
        
        this.listeners.push({el, start, move, end});
    }

    destroy() {
        this.listeners.forEach(l => {
            window.removeEventListener('mousemove', l.move);
            window.removeEventListener('touchmove', l.move);
            window.removeEventListener('mouseup', l.end);
            window.removeEventListener('touchend', l.end);
        });
    }
}
</script>
</body>
</html>